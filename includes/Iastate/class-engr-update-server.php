<?php

class Engr_UpdateServer extends Wpup_UpdateServer {
	/**
	 * @var string|null
	 */
	private $authenticationKey = null;

	/**
	 * @param string $serverUrl
	 * @param string $serverDirectory
	 * @param string $authenticationKey
	 */
	public function __construct( $serverUrl = null, $serverDirectory = null ) {
		if ( null === $serverUrl && defined( 'WP_UPDATE_HOME_URL' ) ) {
			$serverUrl = WP_UPDATE_HOME_URL;
		}
		if ( null === $serverDirectory && defined( 'WP_UPDATE_PACKAGE_PATH' ) ) {
			$serverDirectory = WP_UPDATE_PACKAGE_PATH;
		}
		parent::__construct( $serverUrl, $serverDirectory );

		$this->authenticationKey = base64_encode( WP_UPDATE_SECRET_ID . ':' . WP_UPDATE_SECRET_STRING );
		$this->logDirectory      = WP_UPDATE_ROOT_PATH . '/logs';

		$cache_type = defined( 'WP_UPDATE_CACHE' ) ? trim( strtolower( WP_UPDATE_CACHE ) ) : 'file';
		switch ( $cache_type ) {
			case 'memcached':
			case 'memcache':
				$this->cache = new Memcache_Cache();
				break;
			case 'redis':
				$this->cache = new Redis_Cache();
				break;
			case 'file':
			default:
				$this->cache = new Wpup_FileCache( WP_UPDATE_ROOT_PATH . '/cache' );
				break;
		}
	}

	/**
	 * @return bool
	 */
	public static function isSsl() {
		if ( isset( $_SERVER['HTTP_X_FORWARDED_PROTO'] ) && 'https' === strtolower( $_SERVER['HTTP_X_FORWARDED_PROTO'] ) ) {
			return true;
		}

		return parent::isSsl();
	}

	protected function loadPackageFor( $request ) {
		if ( mb_strpos( $request->slug, ',' ) !== false ) {
			$package_slugs = explode( ',', $request->slug );
			$packages      = [];

			foreach ( $package_slugs as $slug ) {
				$packages[] = $this->findPackage( $slug );
			}
			$request->package = $packages;

			return;
		}

		parent::loadPackageFor( $request );
	}

	protected function actionGetMetadata( Wpup_Request $request ) {
		if ( is_array( $request->package ) ) {
			$packages = [];
			foreach ( $request->package as $package ) {
				if ( $package instanceof Wpup_Package ) {
					$meta                 = $package->getMetadata();
					$meta['download_url'] = $this->generateDownloadUrl( $package );
					$meta['banners']      = $this->getBanners( $package );
					$meta['icons']        = $this->getIcons( $package );

					$meta = $this->filterMetadata( $meta, $request );

					//For debugging. The update checker ignores unknown fields, so this is safe.
					$meta['request_time_elapsed'] = sprintf( '%.3f', microtime( true ) - $this->startTime );

					$packages[] = $meta;
				}
			}

			$this->outputAsJson( $packages );
			exit;
		}
		parent::actionGetMetadata( $request ); // TODO: Change the autogenerated stub
	}

	/**
	 * @param array $meta
	 * @param Wpup_Request $request
	 *
	 * @return array
	 */
	protected function filterMetadata( $meta, $request ) {
		$meta = parent::filterMetadata( $meta, $request );

		//Include license information in the update metadata. This saves an HTTP request
		//or two since the plugin doesn't need to explicitly fetch license details.
		$authKey = $request->authKey;
		if ( $authKey !== null ) {
			$meta['auth_key'] = $authKey;
		}

		//Only include the download URL if the license is valid.
		if ( $this->isAuthenticationKeyValid( $authKey ) ) {
			//Append the license key or to the download URL.
			$args                 = array( 'uid' => $this->generateUniqueQueryArg( $request ) );
			$meta['download_url'] = self::addQueryArg( $args, $meta['download_url'] );
		} else {
			//No license = no download link.
			unset( $meta['download_url'] );
		}

		return $meta;
	}

	/**
	 * @param string $string
	 */
	private function isAuthenticationKeyValid( $string ): bool {
		return $this->authenticationKey === $string;
	}

	/**
	 * @param Wpup_Request $request
	 */
	private function generateUniqueQueryArg( $request ): string {
		$parts = array(
			'action'  => 'download',
			'slug'    => (string) $request->slug,
			'version' => (string) $request->wpVersion,
			'url'     => (string) $request->wpSiteUrl,
		);

		$cache_key = 'query_key:' . implode( '_', $parts );
		$hash      = $this->cache->get( $cache_key );

		if ( null === $hash ) {
			$hash = hash( WP_UPDATE_HASH_ALGO, implode( ';', $parts ) );
			$this->cache->set( $cache_key, $hash );
		}

		return rawurlencode( base64_encode( $hash ) );
	}

	/**
	 * @param array $query
	 * @param array $headers
	 *
	 * @return Wpup_Request
	 */
	protected function initRequest( $query = null, $headers = null ) {
		$request = parent::initRequest( $query, $headers );

		if ( ! empty( $_SERVER['HTTP_X_FORWARDED_FOR'] ) ) {
			$request->clientIp = $_SERVER['HTTP_X_FORWARDED_FOR'];
		}

		//Load the license, if any.
		$authKey = null;
		if ( ! empty( $request->headers->get( 'Authorization' ) ) ) {
			$authKey = urldecode( str_replace( 'Basic ', '', $request->headers->get( 'Authorization' ) ) );
		}

		$request->authKey = $authKey;

		return $request;
	}

	/**
	 * @param Wpup_Request $request
	 *
	 * @return void
	 * @uses exit() if criteria isn't met.
	 */
	protected function checkAuthorization( $request ) {
		parent::checkAuthorization( $request );

		//Prevent download if the user doesn't have a valid license.
		$authHash = $request->param( 'uid' );
		if ( 'download' === $request->action && ! $this->isHashValid( $request ) ) {
			if ( empty( $authHash ) ) {
				$message = 'You must provide a license key to download this plugin.';
			} else {
				$message = 'Sorry, your license is not valid.';
			}
			$this->exitWithError( $message, 403 );
		}
	}

	/**
	 * @param Wpup_Request $request
	 */
	private function isHashValid( $request ): bool {
		$parts    = array(
			'action'  => (string) $request->action,
			'slug'    => (string) $request->slug,
			'version' => (string) $request->wpVersion,
			'url'     => (string) $request->wpSiteUrl,
		);
		$sentHash = base64_decode( urldecode( $request->param( 'uid' ) ) );

		$cache_key = 'query_key:' . implode( '_', $parts );
		$hash      = $this->cache->get( $cache_key );

		return $hash === $sentHash;
	}

	/**
	 * Output something as JSON.
	 *
	 * @param mixed $response
	 */
	protected function outputAsJson($response) {
		header('Content-Type: application/json; charset=utf-8');
		if ( defined('JSON_PRETTY_PRINT') ) {
			$output = $this->jsonEncode($response, JSON_PRETTY_PRINT);
		} else {
			$output = $this->jsonEncode($response);
		}
		//phpcs:ignore WordPress.Security.EscapeOutput.OutputNotEscaped -- The output is JSON, not HTML.
		echo $output;
	}

}
